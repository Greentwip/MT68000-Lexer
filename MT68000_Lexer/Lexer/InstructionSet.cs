using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MT68000_Lexer.Lexer
{
    public class InstructionSet
    {
        public static Dictionary<string, string> Instructions =new Dictionary<string, string>()
        {
            {"abcd","Add BCD with extend"},
            {"add","Add binary"},
            {"adda","Add binary to address register"},
            {"addi","Add immediate"},
            {"addq","Add 3-bit immediate"},
            {"addx","Add extended"},
            {"and","Bitwise AND"},
            {"andi","Bitwise AND immediate"},
            {"asl","Arithmetic shift left"},
            {"asr","Arithmetic shift right"},
            {"bcc","Branch on carry clear"},
            {"bchg","Test a bit and change"},
            {"bclr","Test a bit and clear"},
            {"bcs","Branch on carry set"},
            {"beq","Branch if equal"},
            {"bge","Branch if greater than or equal"},
            {"bgt","Branch if greater than"},
            {"bhi","Branch if higher than"},
            {"bhs","Branch if higher than or same"},
            {"blo","Branch if lower than"},
            {"bls","Branch if lower than or same"},
            {"ble","Branch if less than or equal"},
            {"blt","Branch if less than"},
            {"bmi","Branch if minus (negative)"},
            {"bne","Branch if not equal"},
            {"bpl","Branch if plus (positive)"},
            {"bra","Branch"},
            {"bset","Test a bit and set"},
            {"bsr","Branch to subroutine"},
            {"btst","Bit test"},
            {"chk","Check data register against bounds"},
            {"clr","Clear"},
            {"cmp","Compare"},
            {"cmpa","Compare address"},
            {"cmpi","Compare immediate"},
            {"cmpm","Compare memory"},
            {"dc","Define constant"},
            {"dbcc","Looping instruction - Decrement and branch if [condition]"},
            {"dbeq","Decrement and branch if equal to zero"},
            {"dbf","Decrement and branch if false"},
            {"dbt","Decrement and branch if true"},
            {"divs","Divide signed"},
            {"divu","Divide unsigned"},
            {"eor","Exclusive OR"},
            {"eori","Exclusive OR immediate"},
            {"exg","Exchange any two registers"},
            {"ext","Sign extend"},
            {"jmp","Jump to effective address"},
            {"jsr","Jump to subroutine"},
            {"jsrto","Jump to subroutine - undocumented command"},
            {"lea","Load effective address"},
            {"lsl","Logical shift left"},
            {"lsr","Logical shift right"},
            {"move","Move value into register"},
            {"movea","Move address into register"},
            {"movem","Move multiple"},
            {"movep","Move peripheral"},
            {"moveq","Move 8-bit immediate"},
            {"muls","Multiply signed"},
            {"mulu","Multiply unsigned"},
            {"mvabs","Undocumented command"},
            {"nbcd","Negate BCD"},
            {"neg","Negate"},
            {"negx","Negate with extend"},
            {"nop","No operation"},
            {"not","One's complement"},
            {"or","Bitwise OR"},
            {"ori","Bitwise OR immediate"},
            {"pea","Push effective address"},
            {"reset","Reset all external devices"},
            {"rol","Rotate left"},
            {"ror","Rotate right"},
            {"roxl","Rotate left with extend"},
            {"roxr","Rotate right with extend"},
            {"rte","Return from exception"},
            {"rtr","Return and restore"},
            {"rts","Return from subroutine"},
            {"sbcd","Subtract BCD with extend"},
            {"scc","Set to -1 if True, 0 if False"},
            {"stop","Enable and wait for interrupts"},
            {"sub","Subtract binary"},
            {"suba","Subtract binary from address register"},
            {"subi","Subtract immediate"},
            {"subq","Subtract 3-bit immediate"},
            {"subx","Subtract with extend"},
            {"swap","Swap words of data register"},
            {"tas","Test & Set MSB & Set N/Z-bits"},
            {"trap","Execute TRAP exception"},
            {"trapv","TRAPV exception if V-bit set"},
            {"tst", "Test for negative or zero"},
            {"unlk", "De-allocate stack frame"}
        };

        public static Dictionary<string, string> Addressing = new Dictionary<string, string>()
        {
            {"b", "Byte / 8-bit constant"},
            {"w", "Word / 16-bit constant"},
            {"l", "Long / 32-bit constant"},
            {"x", "Extended / 8-bit/16-bit/32-bit constant"},
        };
    }
}
